var _typeof = require("./typeof.js")["default"];
var checkInRHS = require("./checkInRHS.js");
<<<<<<< HEAD
function _bindPropCall(e, t) {
  return function (r, a) {
    return e[t].call(r, a);
  };
}
function createAddInitializerMethod(e, t) {
  return function (r) {
    if (t.v) throw new Error("attempted to call addInitializer after decoration was finished");
    assertCallable(r, "An initializer", !0), e.push(r);
  };
}
function memberDec(e, t, r, a, n, i, o, s, l, c, u) {
  function assertInstanceIfPrivate(e) {
    return function (t, r) {
      if (!c(t)) throw new TypeError("Attempted to access private element on non-instance");
      return e(t, r);
    };
  }
  var f,
    d,
    p = {
      v: !1
    },
    v = {
      kind: ["field", "accessor", "method", "getter", "setter", "field"][i],
      name: s ? "#" + r : r,
      "static": o,
      "private": s,
      metadata: u,
      addInitializer: createAddInitializerMethod(n, p)
    };
  if (s || 0 !== i && 2 !== i) {
    if (2 === i) f = assertInstanceIfPrivate(function () {
      return a.value;
    });else {
      var h = 0 === i || 1 === i;
      (h || 3 === i) && (f = _bindPropCall(a, "get"), s && (f = assertInstanceIfPrivate(f))), (h || 4 === i) && (d = _bindPropCall(a, "set"), s && (d = assertInstanceIfPrivate(d)));
    }
  } else f = function f(e) {
    return e[r];
  }, 0 === i && (d = function d(e, t) {
    e[r] = t;
  });
  var m = s ? c.bind() : function (e) {
      return r in e;
    },
    b = v.access = {
      has: m
    };
  f && (b.get = f), d && (b.set = d);
  try {
    return e.call(t, l, v);
  } finally {
    p.v = !0;
  }
}
function assertCallable(e, t, r) {
  if ("function" != typeof e && (r || void 0 !== e)) throw new TypeError(t + " must be a function");
}
function assertValidReturnValue(e, t) {
  var r = _typeof(t);
  if (1 === e) {
    if ("object" !== r || !t) throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
    assertCallable(t.get, "accessor.get"), assertCallable(t.set, "accessor.set"), assertCallable(t.init, "accessor.init");
  } else if ("function" !== r) throw new TypeError((0 === e ? "field" : 5 === e ? "class" : "method") + " decorators must return a function or void 0");
}
function applyMemberDec(e, t, r, a, n, i, o, s, l, c, u) {
  var f,
    d,
    p,
    v,
    h = r[0],
    m = r[3];
  a || Array.isArray(h) || (h = [h]), s ? f = 0 === i || 1 === i ? {
    get: function get() {
      return m(this);
    },
    set: function set(e) {
      r[4](this, e);
    }
  } : 3 === i ? {
    get: m
  } : 4 === i ? {
    set: m
  } : {
    value: m
  } : 0 !== i && (f = Object.getOwnPropertyDescriptor(t, n)), 1 === i ? p = {
    get: f.get,
    set: f.set
  } : 2 === i ? p = f.value : 3 === i ? p = f.get : 4 === i && (p = f.set);
  for (var b = a ? 2 : 1, y = h.length - 1; y >= 0; y -= b) {
    var g;
    if (void 0 !== (v = memberDec(h[y], a ? h[y - 1] : void 0, n, f, l, i, o, s, p, c, u))) assertValidReturnValue(i, v), 0 === i ? g = v : 1 === i ? (g = v.init, p = {
      get: v.get || p.get,
      set: v.set || p.set
    }) : p = v, void 0 !== g && (void 0 === d ? d = g : "function" == typeof d ? d = [d, g] : d.push(g));
  }
  if (0 === i || 1 === i) {
    if (void 0 === d) d = function d(e, t) {
      return t;
    };else if ("function" != typeof d) {
      var I = d;
      d = function d(e, t) {
        for (var r = t, a = I.length - 1; a >= 0; a--) r = I[a].call(e, r);
        return r;
      };
    } else {
      var w = d;
      d = d.call.bind(w);
    }
    e.push(d);
  }
  0 !== i && (1 === i ? (f.get = p.get, f.set = p.set) : 2 === i ? f.value = p : 3 === i ? f.get = p : 4 === i && (f.set = p), s ? 1 === i ? e.push(_bindPropCall(f, "get"), _bindPropCall(f, "set")) : e.push(2 === i ? p : Function.call.bind(p)) : Object.defineProperty(t, n, f));
}
function applyMemberDecs(e, t, r, a) {
  var n,
    i,
    o,
    s = [],
    l = new Map(),
    c = new Map();
  function pushInitializers(e) {
    e && s.push(function (t) {
      for (var r = 0; r < e.length; r++) e[r].call(t);
      return t;
    });
  }
  for (var u = 0; u < t.length; u++) {
    var f = t[u];
    if (Array.isArray(f)) {
      var d,
        p,
        v = f[1],
        h = f[2],
        m = f.length > 3,
        b = 16 & v,
        y = !!(8 & v),
        g = r;
      if (v &= 7, y ? (d = e, p = i = i || [], m && !o && (o = function o(t) {
        return checkInRHS(t) === e;
      }), g = o) : (d = e.prototype, p = n = n || []), 0 !== v && !m) {
        var I = y ? c : l,
          w = I.get(h) || 0;
        if (!0 === w || 3 === w && 4 !== v || 4 === w && 3 !== v) throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + h);
        I.set(h, !(!w && v > 2) || v);
      }
      applyMemberDec(s, d, f, b, h, v, y, m, p, g, a);
    }
  }
  return pushInitializers(n), pushInitializers(i), s;
}
function applyClassDecs(e, t, r, a) {
  if (t.length) {
    for (var n = [], i = e, o = e.name, s = r ? 2 : 1, l = t.length - 1; l >= 0; l -= s) {
      var c = {
        v: !1
      };
      try {
        var u = t[l].call(r ? t[l - 1] : void 0, i, {
          kind: "class",
          name: o,
          addInitializer: createAddInitializerMethod(n, c),
          metadata: a
        });
      } finally {
        c.v = !0;
      }
      void 0 !== u && (assertValidReturnValue(5, u), i = u);
    }
    return [defineMetadata(i, a), function () {
      for (var e = 0; e < n.length; e++) n[e].call(i);
    }];
  }
}
function defineMetadata(e, t) {
  return Object.defineProperty(e, Symbol.metadata || Symbol["for"]("Symbol.metadata"), {
    configurable: !0,
    enumerable: !0,
    value: t
  });
}
function applyDecs2305(e, t, r, a, n, i) {
  if (arguments.length >= 6) var o = i[Symbol.metadata || Symbol["for"]("Symbol.metadata")];
  var s = Object.create(void 0 === o ? null : o),
    l = applyMemberDecs(e, t, n, s);
  return r.length || defineMetadata(e, s), {
    e: l,
    get c() {
      return applyClassDecs(e, r, a, s);
=======
var setFunctionName = require("./setFunctionName.js");
var toPropertyKey = require("./toPropertyKey.js");
function applyDecs2305(e, t, r, n, o, a) {
  function i(e, t, r) {
    return function (n, o) {
      return r && r(n), e[t].call(n, o);
    };
  }
  function c(e, t) {
    for (var r = 0; r < e.length; r++) e[r].call(t);
    return t;
  }
  function s(e, t, r, n) {
    if ("function" != typeof e && (n || void 0 !== e)) throw new TypeError(t + " must " + (r || "be") + " a function" + (n ? "" : " or undefined"));
    return e;
  }
  function applyDec(e, t, r, n, o, a, c, u, l, f, p, d, h) {
    function m(e) {
      if (!h(e)) throw new TypeError("Attempted to access private element on non-instance");
    }
    var y,
      v,
      g = t[0],
      b = t[3],
      w = !u;
    if (!w) {
      r || Array.isArray(g) || (g = [g]);
      var S = {},
        A = [],
        P = 3 === o ? "get" : 4 === o || d ? "set" : "value";
      f ? (p || d ? S = {
        get: setFunctionName(function () {
          return b(this);
        }, n, "get"),
        set: function set(e) {
          t[4](this, e);
        }
      } : S[P] = b, p || setFunctionName(S[P], n, 2 === o ? "" : P)) : p || (S = Object.getOwnPropertyDescriptor(e, n));
    }
    for (var j = g.length - 1; j >= 0; j -= r ? 2 : 1) {
      var D = g[j],
        E = r ? g[j - 1] : void 0,
        I = {},
        O = {
          kind: ["field", "accessor", "method", "getter", "setter", "field", "class"][o],
          name: n,
          metadata: a,
          addInitializer: function (e, t) {
            if (e.v) throw new Error("attempted to call addInitializer after decoration was finished");
            s(t, "An initializer", "be", !0), c.push(t);
          }.bind(null, I)
        };
      try {
        if (w) v = D.call(E, e, O);else {
          var k, F;
          O["static"] = l, O["private"] = f, f || !p && 2 !== o ? 2 === o ? k = function k(e) {
            return m(e), S.value;
          } : ((o < 2 || 3 === o) && (k = i(S, "get", f && m)), (o < 2 || 4 === o) && (F = i(S, "set", f && m))) : (k = function k(e) {
            return e[n];
          }, p && (F = function F(e, t) {
            e[n] = t;
          }));
          var N = O.access = {
            has: f ? h.bind() : function (e) {
              return n in e;
            }
          };
          if (k && (N.get = k), F && (N.set = F), v = D.call(E, d ? {
            get: S.get,
            set: S.set
          } : S[P], O), d) {
            if ("object" == _typeof(v) && v) (y = s(v.get, "accessor.get")) && (S.get = y), (y = s(v.set, "accessor.set")) && (S.set = y), (y = s(v.init, "accessor.init")) && A.push(y);else if (void 0 !== v) throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
          } else s(v, (p ? "field" : "method") + " decorators", "return") && (p ? A.push(v) : S[P] = v);
        }
      } finally {
        I.v = !0;
      }
    }
    return (p || d) && u.push(function (e, t) {
      for (var r = A.length - 1; r >= 0; r--) t = A[r].call(e, t);
      return t;
    }), p || w || (f ? d ? u.push(i(S, "get"), i(S, "set")) : u.push(2 === o ? S[P] : i.call.bind(S[P])) : Object.defineProperty(e, n, S)), v;
  }
  function u(e, t) {
    return Object.defineProperty(e, Symbol.metadata || Symbol["for"]("Symbol.metadata"), {
      configurable: !0,
      enumerable: !0,
      value: t
    });
  }
  if (arguments.length >= 6) var l = a[Symbol.metadata || Symbol["for"]("Symbol.metadata")];
  var f = Object.create(null == l ? null : l),
    p = function (e, t, r, n) {
      var o,
        a,
        i = [],
        s = function s(t) {
          return checkInRHS(t) === e;
        },
        u = new Map();
      function l(e) {
        e && i.push(c.bind(null, e));
      }
      for (var f = 0; f < t.length; f++) {
        var p = t[f];
        if (Array.isArray(p)) {
          var d = p[1],
            h = p[2],
            m = p.length > 3,
            y = 16 & d,
            v = !!(8 & d),
            g = 0 == (d &= 7),
            b = h + "/" + v;
          if (!g && !m) {
            var w = u.get(b);
            if (!0 === w || 3 === w && 4 !== d || 4 === w && 3 !== d) throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + h);
            u.set(b, !(d > 2) || d);
          }
          applyDec(v ? e : e.prototype, p, y, m ? "#" + h : toPropertyKey(h), d, n, v ? a = a || [] : o = o || [], i, v, m, g, 1 === d, v && m ? s : r);
        }
      }
      return l(o), l(a), i;
    }(e, t, o, f);
  return r.length || u(e, f), {
    e: p,
    get c() {
      var t = [];
      return r.length && [u(s(applyDec(e, [r], n, e.name, 5, f, t), "class decorators", "return") || e, f), c.bind(null, t, e)];
>>>>>>> jodaj
    }
  };
}
module.exports = applyDecs2305, module.exports.__esModule = true, module.exports["default"] = module.exports;